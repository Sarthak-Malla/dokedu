package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"context"
	"errors"
	"example/pkg/db"
	"example/pkg/graph/model"
	"example/pkg/middleware"
	"fmt"
	"time"
)

// Image is the resolver for the image field.
func (r *eventResolver) Image(ctx context.Context, obj *db.Event) (*db.File, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var file db.File
	err := r.DB.NewSelect().Model(&file).Where("id = ?", obj.ImageFileID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &file, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *eventResolver) DeletedAt(ctx context.Context, obj *db.Event) (*time.Time, error) {
	if obj.DeletedAt.IsZero() {
		return nil, nil
	}

	return &obj.DeletedAt.Time, nil
}

// Competences is the resolver for the competences field.
func (r *eventResolver) Competences(ctx context.Context, obj *db.Event) ([]*db.Competence, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var competences []*db.Competence
	err := r.DB.NewSelect().
		Model(&competences).
		Join("JOIN event_competences ON event_competences.competence_id = competence.id").
		Where("event_competences.event_id = ?", obj.ID).
		Where("competence.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return competences, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*db.Event, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var event db.Event
	event.Title = input.Title

	if input.Body != nil && len(*input.Body) > 0 {
		event.Body = *input.Body
	}

	// parse time properly to avoid error
	layout := "2006-01-02 15:04:05.999999999 -0700 MST"
	startsAt, err := time.Parse(layout, input.StartsAt.String())
	if err != nil {
		return nil, err
	}
	event.StartsAt = startsAt

	endsAt, err := time.Parse(layout, input.EndsAt.String())
	if err != nil {
		return nil, err
	}
	event.EndsAt = endsAt

	event.OrganisationID = currentUser.OrganisationID

	if event.Recurrence == nil {
		event.Recurrence = []string{}
	}

	err = r.DB.NewInsert().Model(&event).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &event, nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEventInput) (*db.Event, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var event db.Event

	query := r.DB.NewUpdate().
		Model(&event).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		Where("id = ?", input.ID)

	if input.Title != nil && len(*input.Title) > 0 {
		event.Title = *input.Title
		query.Set("title = ?", event.Title)
	}

	if input.Body != nil && len(*input.Body) > 0 {
		event.Body = *input.Body
		query.Set("body = ?", event.Body)
	}

	layout := "2006-01-02 15:04:05.999999999 -0700 MST"

	if input.StartsAt != nil {
		startsAt, err := time.Parse(layout, input.StartsAt.String())
		if err != nil {
			return nil, err
		}
		event.StartsAt = startsAt
		query.Set("starts_at = ?", event.StartsAt)
	}

	if input.EndsAt != nil {
		endsAt, err := time.Parse(layout, input.EndsAt.String())
		if err != nil {
			return nil, err
		}
		event.EndsAt = endsAt
		query.Set("ends_at = ?", event.EndsAt)
	}

	if event.Recurrence == nil {
		event.Recurrence = []string{}
		//query.Set("recurrence = ?", event.Recurrence)
	}

	err := query.Scan(ctx)

	if err != nil {
		return nil, err
	}

	return &event, nil
}

// ArchiveEvent is the resolver for the archiveEvent field.
func (r *mutationResolver) ArchiveEvent(ctx context.Context, id string) (*db.Event, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var event db.Event
	// mark event.deleted_at as now
	err := r.DB.NewUpdate().
		Model(&event).
		Set("deleted_at = ?", time.Now()).
		Where("id = ?", id).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		WhereAllWithDeleted().
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &event, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*db.Event, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var event db.Event
	err := r.DB.NewSelect().Model(&event).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &event, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, limit *int, offset *int, filter *model.EventFilterInput, search *string) (*model.EventConnection, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	pageLimit := 10
	if limit != nil {
		if *limit > 1000 {
			return nil, fmt.Errorf("limit cannot be greater than 1000")
		}
		pageLimit = *limit
	}

	pageOffset := 0
	if offset != nil {
		pageOffset = *offset
	}

	var events []*db.Event

	query := r.DB.NewSelect().Model(&events).Where("organisation_id = ?", currentUser.OrganisationID).Limit(pageLimit).Offset(pageOffset)

	if search != nil && len(*search) > 0 {
		// TODO:
		query.TableExpr("to_tsvector('german', event.title || event.body) document")
		query.TableExpr("(SELECT to_tsquery('german', string_agg(lexeme || ':*', ' & ' order by positions)) AS query FROM unnest(to_tsvector('german', ?))) query", *search)
		query.TableExpr("NULLIF(ts_rank(to_tsvector('german', event.title), query), 0) rank_title")
		query.TableExpr("NULLIF(ts_rank(to_tsvector('german', event.body), query), 0) rank_description")
		query.TableExpr("SIMILARITY(?, event.title || event.body) similarity", *search)
		query.Where("query @@ document OR similarity > 0")
		query.OrderExpr("rank_title, rank_description, similarity ASC NULLS LAST")
	} else {
		query.Order("created_at")
	}

	// Filters
	if filter != nil {
		if filter.From != nil {
			query.Where("starts_at >= ?", filter.From)
		}
		if filter.To != nil {
			query.Where("ends_at <= ?", filter.To)
		}
	}

	count, err := query.ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	// Page info
	page := &model.PageInfo{}

	if count < pageOffset+pageLimit {
		page.HasNextPage = false
	} else {
		page.HasNextPage = true
	}

	if pageOffset > 0 {
		page.HasPreviousPage = true
	} else {
		page.HasPreviousPage = false
	}

	page.CurrentPage = pageOffset / pageLimit

	if pageOffset > 0 {
		page.HasPreviousPage = true
	} else {
		page.HasPreviousPage = false
	}

	return &model.EventConnection{
		Edges:      events,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// ExportEvents is the resolver for the exportEvents field.
func (r *queryResolver) ExportEvents(ctx context.Context, input model.ExportEventsInput) ([]*model.ExportEventsPayload, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	orgId := currentUser.OrganisationID

	from := input.From
	to := input.To
	deleted := input.Deleted

	var events []*model.ExportEventsPayload
	err := r.DB.NewRaw("SELECT * FROM export_events(?, ?, ?, ?)", orgId, from, to, deleted).Scan(ctx, &events)
	if err != nil {
		return nil, err
	}

	return events, nil
}

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

type eventResolver struct{ *Resolver }
