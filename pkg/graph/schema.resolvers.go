package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"context"
	"encoding/json"
	"errors"
	"example/pkg/db"
	"example/pkg/graph/model"
	"example/pkg/jwt"
	"example/pkg/middleware"
	"fmt"
	"strings"
	"time"

	jwt2 "github.com/golang-jwt/jwt"
	"golang.org/x/crypto/bcrypt"
)

// Name is the resolver for the name field.
func (r *chatResolver) Name(ctx context.Context, obj *db.Chat) (*string, error) {
	if obj.Name.Valid {
		return &obj.Name.String, nil
	}

	return nil, nil
}

// ChatUsers is the resolver for the chatUsers field.
func (r *chatResolver) ChatUsers(ctx context.Context, obj *db.Chat) ([]*db.ChatUser, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to see the chat
	_, err := r.DB.GetChatUser(ctx, db.GetChatUserParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
		UserID:         currentUser.ID,
	})

	if err != nil {
		return nil, err
	}

	chatUsers, err := r.DB.ListChatUsers(ctx, db.ListChatUsersParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	chatUserPtr := make([]*db.ChatUser, len(chatUsers))
	for i, chatUser := range chatUsers {
		chatUserPr := &chatUser
		chatUserPtr[i] = chatUserPr
	}

	return chatUserPtr, nil
}

// ChatMessages is the resolver for the chatMessages field.
func (r *chatResolver) ChatMessages(ctx context.Context, obj *db.Chat) ([]*db.ChatMessage, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to see the chat
	_, err := r.DB.GetChatUser(ctx, db.GetChatUserParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	chatMessages, err := r.DB.ListChatMessages(ctx, db.ListChatMessagesParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	chatMessagePtr := make([]*db.ChatMessage, len(chatMessages))
	for i, chatMessage := range chatMessages {
		chatMessagePr := &chatMessage
		chatMessagePtr[i] = chatMessagePr
	}

	return chatMessagePtr, nil
}

// Chat is the resolver for the chat field.
func (r *chatMessageResolver) Chat(ctx context.Context, obj *db.ChatMessage) (*db.Chat, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to see the chat
	_, err := r.DB.GetChatUser(ctx, db.GetChatUserParams{
		ChatID:         obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	chat, err := r.DB.GetChat(ctx, db.GetChatParams{
		ID:             obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// User is the resolver for the user field.
func (r *chatMessageResolver) User(ctx context.Context, obj *db.ChatMessage) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to see the chat
	_, err := r.DB.GetChatUser(ctx, db.GetChatUserParams{
		ChatID:         obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Chat is the resolver for the chat field.
func (r *chatUserResolver) Chat(ctx context.Context, obj *db.ChatUser) (*db.Chat, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to see the chat
	_, err := r.DB.GetChatUser(ctx, db.GetChatUserParams{
		ChatID:         obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	chat, err := r.DB.GetChat(ctx, db.GetChatParams{
		ID:             obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// User is the resolver for the user field.
func (r *chatUserResolver) User(ctx context.Context, obj *db.ChatUser) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to see the chat
	_, err := r.DB.GetChatUser(ctx, db.GetChatUserParams{
		ChatID:         obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Type is the resolver for the type field.
func (r *competenceResolver) Type(ctx context.Context, obj *db.Competence) (db.CompetenceType, error) {
	return obj.CompetenceType, nil
}

// Color is the resolver for the color field.
func (r *competenceResolver) Color(ctx context.Context, obj *db.Competence) (string, error) {
	if obj.Color.Valid {
		return obj.Color.String, nil
	}

	return "", nil
}

// Parents is the resolver for the parents field.
func (r *competenceResolver) Parents(ctx context.Context, obj *db.Competence) ([]*db.Competence, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	parents, err := r.DB.CompetenceParents(ctx, db.CompetenceParentsParams{
		ID:             obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	// TODO: this is a bad workaround
	competences := make([]*db.Competence, len(parents))
	for i, competence := range parents {
		competencePr := &competence
		competences[i] = &db.Competence{
			ID:             competencePr.ID,
			Name:           competencePr.Name,
			CompetenceID:   competencePr.CompetenceID,
			CompetenceType: competencePr.CompetenceType,
			OrganisationID: competencePr.OrganisationID,
			Grades:         competencePr.Grades,
			Color:          competencePr.Color,
			CurriculumID:   competencePr.CurriculumID,
			CreatedAt:      competencePr.CreatedAt,
			DeletedAt:      competencePr.DeletedAt,
		}
	}

	return competences, nil
}

// Body is the resolver for the body field.
func (r *entryResolver) Body(ctx context.Context, obj *db.Entry) (*string, error) {
	// obj.Body is a json string, so we need to unmarshal it
	var body string
	err := json.Unmarshal([]byte(obj.Body), &body)
	if err != nil {
		return nil, err
	}

	return &body, nil
}

// Entry is the resolver for the entry field.
func (r *entryEventResolver) Entry(ctx context.Context, obj *db.EntryEvent) (*db.Entry, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	entry, err := r.DB.GetEntry(ctx, db.GetEntryParams{
		ID:             obj.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// Event is the resolver for the event field.
func (r *entryEventResolver) Event(ctx context.Context, obj *db.EntryEvent) (*db.Event, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	event, err := r.DB.GetEvent(ctx, db.GetEventParams{
		ID:             obj.EventID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &event, nil
}

// Entry is the resolver for the entry field.
func (r *entryFileResolver) Entry(ctx context.Context, obj *db.EntryFile) (*db.Entry, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	entry, err := r.DB.GetEntry(ctx, db.GetEntryParams{
		ID:             obj.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// File is the resolver for the file field.
func (r *entryFileResolver) File(ctx context.Context, obj *db.EntryFile) (*db.File, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	file, err := r.DB.GetFile(ctx, db.GetFileParams{
		ID:             obj.FileID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &file, nil
}

// Entry is the resolver for the entry field.
func (r *entryTagResolver) Entry(ctx context.Context, obj *db.EntryTag) (*db.Entry, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	entry, err := r.DB.GetEntry(ctx, db.GetEntryParams{
		ID:             obj.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// Tag is the resolver for the tag field.
func (r *entryTagResolver) Tag(ctx context.Context, obj *db.EntryTag) (*db.Tag, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	tag, err := r.DB.GetTag(ctx, db.GetTagParams{
		ID:             obj.TagID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// Entry is the resolver for the entry field.
func (r *entryUserResolver) Entry(ctx context.Context, obj *db.EntryUser) (*db.Entry, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	entry, err := r.DB.GetEntry(ctx, db.GetEntryParams{
		ID:             obj.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// User is the resolver for the user field.
func (r *entryUserResolver) User(ctx context.Context, obj *db.EntryUser) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Entry is the resolver for the entry field.
func (r *entryUserCompetenceResolver) Entry(ctx context.Context, obj *db.EntryUserCompetence) (*db.Entry, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	entry, err := r.DB.GetEntry(ctx, db.GetEntryParams{
		ID:             obj.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// User is the resolver for the user field.
func (r *entryUserCompetenceResolver) User(ctx context.Context, obj *db.EntryUserCompetence) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Competence is the resolver for the competence field.
func (r *entryUserCompetenceResolver) Competence(ctx context.Context, obj *db.EntryUserCompetence) (*db.Competence, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	competence, err := r.DB.GetCompetence(ctx, db.GetCompetenceParams{
		ID:             obj.CompetenceID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// Image is the resolver for the image field.
func (r *eventResolver) Image(ctx context.Context, obj *db.Event) (*db.File, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	file, err := r.DB.GetFile(ctx, db.GetFileParams{
		ID:             obj.ImageFileID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &file, nil
}

// URL is the resolver for the url field.
func (r *fileResolver) URL(ctx context.Context, obj *db.File) (string, error) {
	// TODO: implement this
	return fmt.Sprintf("https://api.dokedu.org/files/%s", obj.ID), nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInPayload, error) {
	// get the user by email
	user, err := r.DB.GetAuthUserByEmail(ctx, input.Email)

	if err != nil {
		return nil, errors.New("invalid email or password")
	}

	// user.Password is a sql.NullString, so we need to check if it is valid
	if !user.Password.Valid {
		return nil, errors.New("invalid email or password")
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password.String), []byte(input.Password)); err != nil {
		return nil, errors.New("invalid email or password")
	}

	// custom field to remove the password from the user
	jwtUser := jwt.User{
		ID:             user.ID,
		Role:           user.Role,
		OrganisationID: user.OrganisationID,
		FirstName:      user.FirstName,
		LastName:       user.LastName,
		Email:          user.Email,
	}

	// TODO: add the secret to the environment variables
	signer := jwt.NewSigner("12345678")

	// generate a new JWT token
	token, err := signer.Sign(jwt.Claims{
		User: jwtUser,
		StandardClaims: jwt2.StandardClaims{
			IssuedAt:  time.Now().Unix(),
			ExpiresAt: time.Now().Add(time.Hour * 24 * 7).Unix(),
		},
	})

	if err != nil {
		return nil, errors.New("unable to sign the token")
	}

	return &model.SignInPayload{
		Token: token,
	}, nil
}

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input model.SignUpInput) (*model.SignInPayload, error) {
	// TODO: add input.OrganisationId to schema

	return nil, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	if currentUser.Role != db.UserRoleOwner {
		return nil, errors.New("you are not allowed to create users")
	}

	organisation, err := r.DB.GetOrganisation(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	// check if the email is in the allowed domains
	if isStringInArray(input.Email, organisation.AllowedDomains) {
		return nil, errors.New("email is not in the allowed domains (allowed domains: " + strings.Join(organisation.AllowedDomains, ", ") + ")")
	}

	// check if the email is already in the database
	count, err := r.DB.GetUserByEmail(ctx, db.GetUserByEmailParams{
		OrganisationID: currentUser.OrganisationID,
		Email:          input.Email,
	})

	if err != nil {
		return nil, err
	}

	if count > 0 {
		return nil, errors.New("email is already in the database")
	}

	// create a new user
	user, err := r.DB.CreateUser(ctx, db.CreateUserParams{
		OrganisationID: currentUser.OrganisationID,
		Role:           input.Role,
		Email:          input.Email,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to update the user (only admins or higher can update users)
	if currentUser.Role != db.UserRoleAdmin && currentUser.Role != db.UserRoleOwner {
		return nil, errors.New("you are not allowed to update users")
	}

	// update the user
	user, err := r.DB.UpdateUser(ctx, db.UpdateUserParams{
		ID:             input.ID,
		OrganisationID: currentUser.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// InviteUser is the resolver for the inviteUser field.
func (r *mutationResolver) InviteUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	organisation, err := r.DB.GetOrganisation(ctx, currentUser.OrganisationID)

	if err != nil {
		return nil, err
	}

	if input.Email == "" {
		return nil, errors.New("email is required")
	}

	// check if the email is in the allowed domains
	if isStringInArray(input.Email, organisation.AllowedDomains) {
		return nil, errors.New("email is not in the allowed domains (allowed domains: " + strings.Join(organisation.AllowedDomains, ", ") + ")")
	}

	// check if the email is already in the database
	count, err := r.DB.GetUserByEmail(ctx, db.GetUserByEmailParams{
		OrganisationID: currentUser.OrganisationID,
		Email:          input.Email,
	})

	if err != nil {
		return nil, err
	}

	if count > 0 {
		return nil, errors.New("email is already in the database")
	}

	// create a new user
	user, err := r.DB.CreateUser(ctx, db.CreateUserParams{
		OrganisationID: currentUser.OrganisationID,
		Email:          input.Email,
		Role:           input.Role,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to archive the user (only admins or higher can archive users)
	if currentUser.Role != db.UserRoleAdmin && currentUser.Role != db.UserRoleOwner {
		return nil, errors.New("you are not allowed to archive users")
	}

	// check whether the user is already archived
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	if !user.DeletedAt.Valid {
		return nil, errors.New("user is already archived")
	}

	// archive the user
	user, err = r.DB.ArchiveUser(ctx, db.ArchiveUserParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// CreateEntry is the resolver for the createEntry field.
func (r *mutationResolver) CreateEntry(ctx context.Context, input model.CreateEntryInput) (*db.Entry, error) {
	panic(fmt.Errorf("not implemented: CreateEntry - createEntry"))
}

// UpdateEntry is the resolver for the updateEntry field.
func (r *mutationResolver) UpdateEntry(ctx context.Context, id string, input model.UpdateEntryInput) (*db.Entry, error) {
	panic(fmt.Errorf("not implemented: UpdateEntry - updateEntry"))
}

// CreateEntryEvent is the resolver for the createEntryEvent field.
func (r *mutationResolver) CreateEntryEvent(ctx context.Context, entryID string, eventID string) (*db.EntryEvent, error) {
	panic(fmt.Errorf("not implemented: CreateEntryEvent - createEntryEvent"))
}

// DeleteEntryEvent is the resolver for the deleteEntryEvent field.
func (r *mutationResolver) DeleteEntryEvent(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntryEvent - deleteEntryEvent"))
}

// CreateEntryFile is the resolver for the createEntryFile field.
func (r *mutationResolver) CreateEntryFile(ctx context.Context, entryID string, fileID string) (*db.EntryFile, error) {
	panic(fmt.Errorf("not implemented: CreateEntryFile - createEntryFile"))
}

// DeleteEntryFile is the resolver for the deleteEntryFile field.
func (r *mutationResolver) DeleteEntryFile(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntryFile - deleteEntryFile"))
}

// CreateEntryUser is the resolver for the createEntryUser field.
func (r *mutationResolver) CreateEntryUser(ctx context.Context, entryID string, userID string) (*db.EntryUser, error) {
	panic(fmt.Errorf("not implemented: CreateEntryUser - createEntryUser"))
}

// DeleteEntryUser is the resolver for the deleteEntryUser field.
func (r *mutationResolver) DeleteEntryUser(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntryUser - deleteEntryUser"))
}

// CreateEntryUserCompetence is the resolver for the createEntryUserCompetence field.
func (r *mutationResolver) CreateEntryUserCompetence(ctx context.Context, entryID string, userCompetenceID string, level int) (*db.EntryUserCompetence, error) {
	panic(fmt.Errorf("not implemented: CreateEntryUserCompetence - createEntryUserCompetence"))
}

// UpdateEntryUserCompetence is the resolver for the updateEntryUserCompetence field.
func (r *mutationResolver) UpdateEntryUserCompetence(ctx context.Context, id string, level int) (*db.EntryUserCompetence, error) {
	panic(fmt.Errorf("not implemented: UpdateEntryUserCompetence - updateEntryUserCompetence"))
}

// DeleteEntryUserCompetence is the resolver for the deleteEntryUserCompetence field.
func (r *mutationResolver) DeleteEntryUserCompetence(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntryUserCompetence - deleteEntryUserCompetence"))
}

// CreateEntryTag is the resolver for the createEntryTag field.
func (r *mutationResolver) CreateEntryTag(ctx context.Context, entryID string, tagID string) (*db.EntryTag, error) {
	panic(fmt.Errorf("not implemented: CreateEntryTag - createEntryTag"))
}

// DeleteEntryTag is the resolver for the deleteEntryTag field.
func (r *mutationResolver) DeleteEntryTag(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntryTag - deleteEntryTag"))
}

// CreateReport is the resolver for the createReport field.
func (r *mutationResolver) CreateReport(ctx context.Context, input model.CreateReportInput) (*db.Report, error) {
	panic(fmt.Errorf("not implemented: CreateReport - createReport"))
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	panic(fmt.Errorf("not implemented: UpdatePassword - updatePassword"))
}

// Owner is the resolver for the owner field.
func (r *organisationResolver) Owner(ctx context.Context, obj *db.Organisation) (*db.User, error) {
	// query the owner of the organisation
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.OwnerID,
		OrganisationID: obj.ID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Organisation is the resolver for the organisation field.
func (r *queryResolver) Organisation(ctx context.Context) (*db.Organisation, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the organisation
	organisation, err := r.DB.GetOrganisation(ctx, currentUser.OrganisationID)

	if err != nil {
		return nil, err
	}

	return &organisation, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput, search *string) (*model.UserConnection, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the users
	users, err := r.DB.ListUsers(ctx, currentUser.OrganisationID)

	if err != nil {
		return nil, err
	}

	usersPtr := make([]*db.User, len(users))

	for i, user := range users {
		userCopy := user
		usersPtr[i] = &userCopy
	}

	return &model.UserConnection{
		Edges:      usersPtr,
		PageInfo:   nil,
		TotalCount: len(users),
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the user
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Competence is the resolver for the competence field.
func (r *queryResolver) Competence(ctx context.Context, id string) (*db.Competence, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the competence
	competence, err := r.DB.GetCompetence(ctx, db.GetCompetenceParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// Competences is the resolver for the competences field.
func (r *queryResolver) Competences(ctx context.Context, limit *int, offset *int, filter *model.CompetenceFilterInput, search *string) (*model.CompetenceConnection, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	competenceTypes := make([]db.CompetenceType, len(filter.Type))
	for i, competenceType := range filter.Type {
		competenceTypes[i] = *competenceType
	}

	parentIds := make([]string, len(filter.Parents))
	for i, parentId := range filter.Parents {
		parentIds[i] = *parentId
	}

	pageLimit := int32(10)
	if limit != nil {
		pageLimit = int32(*limit)
	}

	pageOffset := int32(0)
	if offset != nil {
		pageOffset = int32(*offset)
	}

	// query the competences
	competences, err := r.DB.ListCompetences(ctx, db.ListCompetencesParams{
		OrganisationID:  currentUser.OrganisationID,
		Limit:           pageLimit,
		Offset:          pageOffset,
		CompetenceTypes: competenceTypes,
		ParentIds:       parentIds,
	})

	if err != nil {
		return nil, err
	}

	competencesPtr := make([]*db.Competence, len(competences))

	for i, competence := range competences {
		competenceCopy := competence
		competencesPtr[i] = &competenceCopy
	}

	return &model.CompetenceConnection{
		Edges:      competencesPtr,
		PageInfo:   nil,
		TotalCount: len(competences),
	}, nil
}

// Entry is the resolver for the entry field.
func (r *queryResolver) Entry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the entry
	entry, err := r.DB.GetEntry(ctx, db.GetEntryParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// Entries is the resolver for the entries field.
func (r *queryResolver) Entries(ctx context.Context, limit *int, offset *int, filter *model.EntryFilterInput, search *string) (*model.EntryConnection, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	pageLimit := int32(10)
	if limit != nil {
		pageLimit = int32(*limit)
	}

	pageOffset := int32(0)
	if offset != nil {
		pageOffset = int32(*offset)
	}

	// query the entries
	entries, err := r.DB.ListEntries(ctx, db.ListEntriesParams{
		OrganisationID: currentUser.OrganisationID,
		Limit:          pageLimit,
		Offset:         pageOffset,
	})

	if err != nil {
		return nil, err
	}

	entriesPtr := make([]*db.Entry, len(entries))

	for i, entry := range entries {
		entryCopy := entry
		entriesPtr[i] = &entryCopy
	}

	return &model.EntryConnection{
		Edges:      entriesPtr,
		PageInfo:   nil,
		TotalCount: len(entries),
	}, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*db.Event, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the event
	event, err := r.DB.GetEvent(ctx, db.GetEventParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &event, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, limit *int, offset *int, filter *model.EventFilterInput, search *string) (*model.EventConnection, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	pageLimit := int32(10)
	if limit != nil {
		pageLimit = int32(*limit)
	}

	pageOffset := int32(0)
	if offset != nil {
		pageOffset = int32(*offset)
	}

	// query the events
	events, err := r.DB.ListEvents(ctx, db.ListEventsParams{
		OrganisationID: currentUser.OrganisationID,
		Limit:          pageLimit,
		Offset:         pageOffset,
	})

	if err != nil {
		return nil, err
	}

	eventsPtr := make([]*db.Event, len(events))

	for i, event := range events {
		eventCopy := event
		eventsPtr[i] = &eventCopy
	}

	return &model.EventConnection{
		Edges:      eventsPtr,
		PageInfo:   nil,
		TotalCount: len(events),
	}, nil
}

// Report is the resolver for the report field.
func (r *queryResolver) Report(ctx context.Context, id string) (*db.Report, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the report
	report, err := r.DB.GetReport(ctx, db.GetReportParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &report, nil
}

// Reports is the resolver for the reports field.
func (r *queryResolver) Reports(ctx context.Context, limit *int, offset *int) (*model.ReportConnection, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	pageLimit := int32(10)
	if limit != nil {
		pageLimit = int32(*limit)
	}

	pageOffset := int32(0)
	if offset != nil {
		pageOffset = int32(*offset)
	}

	// query the reports
	reports, err := r.DB.ListReports(ctx, db.ListReportsParams{
		OrganisationID: currentUser.OrganisationID,
		Limit:          pageLimit,
		Offset:         pageOffset,
	})

	if err != nil {
		return nil, err
	}

	reportsPtr := make([]*db.Report, len(reports))

	for i, report := range reports {
		reportCopy := report
		reportsPtr[i] = &reportCopy
	}

	return &model.ReportConnection{
		Edges:      reportsPtr,
		PageInfo:   nil,
		TotalCount: len(reports),
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*db.Tag, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the tag
	tag, err := r.DB.GetTag(ctx, db.GetTagParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, limit *int, offset *int) ([]*db.Tag, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	pageLimit := int32(10)
	if limit != nil {
		pageLimit = int32(*limit)
	}

	pageOffset := int32(0)
	if offset != nil {
		pageOffset = int32(*offset)
	}

	// query the tags
	tags, err := r.DB.ListTags(ctx, db.ListTagsParams{
		OrganisationID: currentUser.OrganisationID,
		Limit:          pageLimit,
		Offset:         pageOffset,
	})

	if err != nil {
		return nil, err
	}

	tagsPtr := make([]*db.Tag, len(tags))

	for i, tag := range tags {
		tagCopy := tag
		tagsPtr[i] = &tagCopy
	}

	return tagsPtr, nil
}

// Chats is the resolver for the chats field.
func (r *queryResolver) Chats(ctx context.Context, limit *int, offset *int) (*model.ChatConnection, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	totalCount, err := r.DB.TotalCountChats(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	// query the chats
	chats, err := r.DB.ListChats(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	chatsPtr := make([]*db.Chat, len(chats))
	for i, chat := range chats {
		chatCopy := chat
		chatsPtr[i] = &chatCopy
	}

	return &model.ChatConnection{
		Edges:      chatsPtr,
		PageInfo:   nil,
		TotalCount: int(totalCount),
	}, nil
}

// Meta is the resolver for the meta field.
func (r *reportResolver) Meta(ctx context.Context, obj *db.Report) (string, error) {
	/// meta is a jsonb field, so we need to unmarshal it
	var meta map[string]interface{}
	err := json.Unmarshal(obj.Meta.RawMessage, &meta)
	if err != nil {
		return "", err
	}

	// return meta as a string
	return fmt.Sprintf("%v", meta), nil
}

// User is the resolver for the user field.
func (r *reportResolver) User(ctx context.Context, obj *db.Report) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the user
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// StudentUser is the resolver for the studentUser field.
func (r *reportResolver) StudentUser(ctx context.Context, obj *db.Report) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the user
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.StudentUserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// File is the resolver for the file field.
func (r *reportResolver) File(ctx context.Context, obj *db.Report) (*db.File, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the file
	file, err := r.DB.GetFile(ctx, db.GetFileParams{
		ID:             obj.FileID.String,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &file, nil
}

// Color is the resolver for the color field.
func (r *tagResolver) Color(ctx context.Context, obj *db.Tag) (string, error) {
	if obj.Color.Valid {
		return obj.Color.String, nil
	}

	return "", nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// ChatMessage returns ChatMessageResolver implementation.
func (r *Resolver) ChatMessage() ChatMessageResolver { return &chatMessageResolver{r} }

// ChatUser returns ChatUserResolver implementation.
func (r *Resolver) ChatUser() ChatUserResolver { return &chatUserResolver{r} }

// Competence returns CompetenceResolver implementation.
func (r *Resolver) Competence() CompetenceResolver { return &competenceResolver{r} }

// Entry returns EntryResolver implementation.
func (r *Resolver) Entry() EntryResolver { return &entryResolver{r} }

// EntryEvent returns EntryEventResolver implementation.
func (r *Resolver) EntryEvent() EntryEventResolver { return &entryEventResolver{r} }

// EntryFile returns EntryFileResolver implementation.
func (r *Resolver) EntryFile() EntryFileResolver { return &entryFileResolver{r} }

// EntryTag returns EntryTagResolver implementation.
func (r *Resolver) EntryTag() EntryTagResolver { return &entryTagResolver{r} }

// EntryUser returns EntryUserResolver implementation.
func (r *Resolver) EntryUser() EntryUserResolver { return &entryUserResolver{r} }

// EntryUserCompetence returns EntryUserCompetenceResolver implementation.
func (r *Resolver) EntryUserCompetence() EntryUserCompetenceResolver {
	return &entryUserCompetenceResolver{r}
}

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// File returns FileResolver implementation.
func (r *Resolver) File() FileResolver { return &fileResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Organisation returns OrganisationResolver implementation.
func (r *Resolver) Organisation() OrganisationResolver { return &organisationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Report returns ReportResolver implementation.
func (r *Resolver) Report() ReportResolver { return &reportResolver{r} }

// Tag returns TagResolver implementation.
func (r *Resolver) Tag() TagResolver { return &tagResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type chatResolver struct{ *Resolver }
type chatMessageResolver struct{ *Resolver }
type chatUserResolver struct{ *Resolver }
type competenceResolver struct{ *Resolver }
type entryResolver struct{ *Resolver }
type entryEventResolver struct{ *Resolver }
type entryFileResolver struct{ *Resolver }
type entryTagResolver struct{ *Resolver }
type entryUserResolver struct{ *Resolver }
type entryUserCompetenceResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type fileResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type organisationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reportResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

func isStringInArray(s string, a []string) bool {
	for _, v := range a {
		if v == s {
			return true
		}
	}

	return false
}
