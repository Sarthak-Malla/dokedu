package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"context"
	"errors"
	"example/pkg/db"
	"example/pkg/graph/model"
	"example/pkg/jwt"
	"example/pkg/middleware"
	"strings"
	"time"

	jwt2 "github.com/golang-jwt/jwt"
	"golang.org/x/crypto/bcrypt"
)

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInPayload, error) {
	// TODO: security
	// TODO: logout, blacklist tokens

	// get the user by email
	user, err := r.DB.GetAuthUserByEmail(ctx, input.Email)

	if err != nil {
		return nil, errors.New("invalid email or password")
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
		return nil, errors.New("invalid email or password")
	}

	// custom field to remove the password from the user
	jwtUser := jwt.User{
		ID:             user.ID,
		Role:           user.Role,
		OrganisationID: user.OrganisationID,
		FirstName:      user.FirstName,
		LastName:       user.LastName,
		Email:          user.Email,
	}

	signer := jwt.NewSigner("12345678")

	// generate a new JWT token
	token, err := signer.Sign(jwt.Claims{
		User: jwtUser,
		StandardClaims: jwt2.StandardClaims{
			IssuedAt:  time.Now().Unix(),
			ExpiresAt: time.Now().Add(time.Hour * 24 * 7).Unix(),
		},
	})

	if err != nil {
		return nil, errors.New("unable to sign the token")
	}

	return &model.SignInPayload{
		Token: token,
	}, nil
}

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input model.SignUpInput) (*model.SignInPayload, error) {
	// TODO: add input.OrganisationId to schema

	return nil, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)

	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	if currentUser.Role != db.UserRoleOwner {
		return nil, errors.New("you are not allowed to create users")
	}

	organisation, err := r.DB.GetOrganisation(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	// check if the email is in the allowed domains
	if isStringInArray(input.Email, organisation.AllowedDomains) {
		return nil, errors.New("email is not in the allowed domains (allowed domains: " + strings.Join(organisation.AllowedDomains, ", ") + ")")
	}

	// check if the email is already in the database
	count, err := r.DB.GetUserByEmail(ctx, db.GetUserByEmailParams{
		OrganisationID: currentUser.OrganisationID,
		Email:          input.Email,
	})

	if err != nil {
		return nil, err
	}

	if count > 0 {
		return nil, errors.New("email is already in the database")
	}

	// create a new user
	user, err := r.DB.CreateUser(ctx, db.CreateUserParams{
		OrganisationID: currentUser.OrganisationID,
		Role:           input.Role,
		Email:          input.Email,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to update the user (only admins or higher can update users)
	if currentUser.Role != db.UserRoleAdmin && currentUser.Role != db.UserRoleOwner {
		return nil, errors.New("you are not allowed to update users")
	}

	// update the user
	user, err := r.DB.UpdateUser(ctx, db.UpdateUserParams{
		ID:             input.ID,
		OrganisationID: currentUser.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// InviteUser is the resolver for the inviteUser field.
func (r *mutationResolver) InviteUser(ctx context.Context, input model.InviteUserInput) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	organisation, err := r.DB.GetOrganisation(ctx, currentUser.OrganisationID)

	if err != nil {
		return nil, err
	}

	if input.Email == "" {
		return nil, errors.New("email is required")
	}

	// check if the email is in the allowed domains
	if isStringInArray(input.Email, organisation.AllowedDomains) {
		return nil, errors.New("email is not in the allowed domains (allowed domains: " + strings.Join(organisation.AllowedDomains, ", ") + ")")
	}

	// check if the email is already in the database
	count, err := r.DB.GetUserByEmail(ctx, db.GetUserByEmailParams{
		OrganisationID: "1",
		Email:          input.Email,
	})

	if err != nil {
		return nil, err
	}

	if count > 0 {
		return nil, errors.New("email is already in the database")
	}

	// create a new user
	user, err := r.DB.InviteUserByEmail(ctx, db.InviteUserByEmailParams{
		OrganisationID: "1",
		Email:          input.Email,
		Role:           input.Role,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// check if the user is allowed to archive the user (only admins or higher can archive users)
	if currentUser.Role != db.UserRoleAdmin && currentUser.Role != db.UserRoleOwner {
		return nil, errors.New("you are not allowed to archive users")
	}

	// check whether the user is already archived
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	if !user.DeletedAt.Valid {
		return nil, errors.New("user is already archived")
	}

	// archive the user
	user, err = r.DB.ArchiveUser(ctx, db.ArchiveUserParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Owner is the resolver for the owner field.
func (r *organisationResolver) Owner(ctx context.Context, obj *db.Organisation) (*db.User, error) {
	// query the owner of the organisation
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             obj.OwnerID,
		OrganisationID: obj.ID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Organisation is the resolver for the organisation field.
func (r *queryResolver) Organisation(ctx context.Context) (*db.Organisation, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the organisation
	organisation, err := r.DB.GetOrganisation(ctx, currentUser.OrganisationID)

	if err != nil {
		return nil, err
	}

	return &organisation, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput) (*model.UserConnection, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the users
	users, err := r.DB.ListUsers(ctx, currentUser.OrganisationID)

	if err != nil {
		return nil, err
	}

	usersPtr := make([]*db.User, len(users))

	for i, user := range users {
		usersPtr[i] = &user
	}

	return &model.UserConnection{
		Edges:      usersPtr,
		PageInfo:   nil,
		TotalCount: len(users),
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	// query the user
	user, err := r.DB.GetUser(ctx, db.GetUserParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return &user, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Organisation returns OrganisationResolver implementation.
func (r *Resolver) Organisation() OrganisationResolver { return &organisationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type organisationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

func isStringInArray(s string, a []string) bool {
	for _, v := range a {
		if v == s {
			return true
		}
	}

	return false
}
