package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"context"
	"database/sql"
	"errors"
	"example/pkg/db"
	"example/pkg/graph/model"
	"example/pkg/middleware"
	"fmt"
	"time"
)

// FileSize is the resolver for the fileSize field.
func (r *fileResolver) FileSize(ctx context.Context, obj *db.File) (int, error) {
	return int(obj.Size), nil
}

// Parent is the resolver for the parent field.
func (r *fileResolver) Parent(ctx context.Context, obj *db.File) (*db.File, error) {
	panic(fmt.Errorf("not implemented: Parent - parent"))
}

// DeletedAt is the resolver for the deletedAt field.
func (r *fileResolver) DeletedAt(ctx context.Context, obj *db.File) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: DeletedAt - deletedAt"))
}

// SingleUpload is the resolver for the singleUpload field.
func (r *mutationResolver) SingleUpload(ctx context.Context, input model.FileUploadInput) (*db.File, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var user db.User
	err := r.DB.NewSelect().Model(&user).Column("bucket_id").Where("id = ?", currentUser.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	var file db.File
	file.Name = input.File.Filename
	file.FileType = "blob"
	file.OrganisationID = currentUser.OrganisationID
	file.Size = input.File.Size

	if input.FolderID != nil && len(*input.FolderID) > 0 {
		file.ParentID = sql.NullString{String: *input.FolderID, Valid: true}
	}

	err = r.DB.NewInsert().Model(&file).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	if input.FolderID == nil {
		var userFile db.UserFiles
		userFile.FileID = file.ID
		userFile.UserID = currentUser.ID
		userFile.OrganisationID = currentUser.OrganisationID
		err = r.DB.NewInsert().Model(&userFile).Returning("*").Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	//exists, err := r.MinioClient.BucketExists(ctx, user.BucketID)
	//if err != nil {
	//	return nil, err
	//}
	//
	//if !exists {
	//	err = r.MinioClient.MakeBucket(ctx, user.BucketID, minio.MakeBucketOptions{})
	//	if err != nil {
	//		return nil, err
	//	}
	//}
	//
	//filename := input.File.Filename
	//
	//if input.FolderID != nil {
	//	filename = fmt.Sprintf("%s%s", *input.FolderID, input.File.Filename)
	//}
	//
	//info, err := r.MinioClient.PutObject(ctx, user.BucketID, filename, input.File.File, input.File.Size, minio.PutObjectOptions{ContentType: input.File.ContentType})
	//if err != nil {
	//	return nil, err
	//}

	return &file, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, input model.CreateFolderInput) (*db.File, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var user db.User
	err := r.DB.NewSelect().Model(&user).Column("bucket_id").Where("id = ?", currentUser.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	var file db.File
	file.Name = input.Name
	file.FileType = "folder"
	file.OrganisationID = currentUser.OrganisationID

	if input.FolderID != nil && len(*input.FolderID) > 0 {
		file.ParentID = sql.NullString{String: *input.FolderID, Valid: true}
	}

	err = r.DB.NewInsert().Model(&file).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	if input.FolderID != nil && len(*input.FolderID) == 0 {
		var userFile db.UserFiles
		userFile.FileID = file.ID
		userFile.UserID = currentUser.ID
		userFile.OrganisationID = currentUser.OrganisationID
		err = r.DB.NewInsert().Model(&userFile).Returning("*").Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	return &file, nil
}

// UserFiles is the resolver for the userFiles field.
func (r *queryResolver) UserFiles(ctx context.Context, input *model.UserFileFilterInput) ([]*db.File, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return nil, errors.New("no user found in the context")
	}

	var user db.User
	err := r.DB.NewSelect().Model(&user).Column("bucket_id").Where("id = ?", currentUser.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	var files []*db.File

	if input != nil && input.FolderID != nil {
		err = r.DB.NewSelect().Model(&files).Where("organisation_id = ?", currentUser.OrganisationID).Where("parent_id = ?", *input.FolderID).Order("file_type").Order("name").Scan(ctx)

	} else {
		err = r.DB.NewSelect().Model(&files).Join("JOIN user_files uf on uf.file_id = file.id").Where("uf.user_id = ?", currentUser.ID).Order("file_type").Order("name").Scan(ctx)
	}

	return files, nil
}

// SharedDrives is the resolver for the sharedDrives field.
func (r *queryResolver) SharedDrives(ctx context.Context, input *model.SharedDriveFilterInput) ([]*db.SharedDrive, error) {
	panic(fmt.Errorf("not implemented: SharedDrives - sharedDrives"))
}

// Files is the resolver for the files field.
func (r *sharedDriveResolver) Files(ctx context.Context, obj *db.SharedDrive) ([]*db.File, error) {
	panic(fmt.Errorf("not implemented: Files - files"))
}

// File returns FileResolver implementation.
func (r *Resolver) File() FileResolver { return &fileResolver{r} }

// SharedDrive returns SharedDriveResolver implementation.
func (r *Resolver) SharedDrive() SharedDriveResolver { return &sharedDriveResolver{r} }

type fileResolver struct{ *Resolver }
type sharedDriveResolver struct{ *Resolver }
