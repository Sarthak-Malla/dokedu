package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"fmt"
	"mime"
	"path/filepath"
	"strings"
	"time"

	"github.com/dokedu/dokedu/backend/internal/dataloaders"
	"github.com/dokedu/dokedu/backend/internal/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	minio "github.com/minio/minio-go/v7"
)

// User is the resolver for the user field.
func (r *bucketResolver) User(ctx context.Context, obj *db.Bucket) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// If the bucket is not owned by a user, return nil.
	if !obj.UserID.Valid {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID.String, currentUser)
}

// DeletedAt is the resolver for the deletedAt field.
func (r *bucketResolver) DeletedAt(ctx context.Context, obj *db.Bucket) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: DeletedAt - deletedAt"))
}

// Files is the resolver for the files field.
func (r *bucketResolver) Files(ctx context.Context, obj *db.Bucket) ([]*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var files []*db.File
	err = r.DB.NewSelect().Model(&files).Where("bucket_id = ?", obj.ID).Where("organisation_id = ?", currentUser.OrganisationID).Order("name").Scan(ctx)
	if err != nil {
		return nil, err
	}

	return files, nil
}

// Bucket is the resolver for the bucket field.
func (r *fileResolver) Bucket(ctx context.Context, obj *db.File) (*db.Bucket, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var bucket db.Bucket
	err = r.DB.NewSelect().Model(&bucket).Where("id = ?", obj.BucketID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &bucket, nil
}

// Parent is the resolver for the parent field.
func (r *fileResolver) Parent(ctx context.Context, obj *db.File) (*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if !obj.ParentID.Valid {
		return nil, nil
	}

	var parent db.File
	err = r.DB.NewSelect().Model(&parent).Where("id = ?", obj.ParentID.String).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &parent, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *fileResolver) DeletedAt(ctx context.Context, obj *db.File) (*time.Time, error) {
	if !obj.DeletedAt.IsZero() {
		return nil, nil
	}

	deletedAt := obj.DeletedAt.Time
	return &deletedAt, nil
}

// Parents is the resolver for the parents field.
func (r *fileResolver) Parents(ctx context.Context, obj *db.File) ([]*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	query := `
WITH RECURSIVE file_parents AS (
    SELECT *, 1 AS level
    FROM files
    WHERE id = ? AND organisation_id = ?
    
    UNION ALL
    
    SELECT f.*, fp.level + 1
    FROM files f
    JOIN file_parents fp ON f.id = fp.parent_id
	WHERE f.organisation_id = ?
)
SELECT file_parents.id, file_parents.name, file_parents.file_type, file_parents.mime_type, file_parents.size, file_parents.bucket_id, file_parents.parent_id, file_parents.organisation_id, file_parents.created_at, file_parents.deleted_at
FROM file_parents
WHERE id <> ?
ORDER BY level DESC;
`

	// query without new lines
	q := strings.ReplaceAll(query, "\n", " ")

	var files []*db.File
	err = r.DB.NewRaw(q, obj.ID, currentUser.OrganisationID, currentUser.OrganisationID, obj.ID).Scan(ctx, &files)
	if err != nil {
		return nil, err
	}

	return files, nil
}

// Files is the resolver for the files field.
func (r *fileResolver) Files(ctx context.Context, obj *db.File) ([]*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var files []*db.File
	err = r.DB.NewSelect().Model(&files).Where("parent_id = ?", obj.ID).Where("organisation_id = ?", currentUser.OrganisationID).Order("name").Scan(ctx)
	if err != nil {
		return nil, err
	}

	return files, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, input model.FileUploadInput) (*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var file db.File
	file.Name = input.File.Filename
	file.FileType = "blob"
	file.OrganisationID = currentUser.OrganisationID
	file.Size = input.File.Size

	// parse MIME type
	mimeFileType := mime.TypeByExtension(filepath.Ext(input.File.Filename))
	file.MimeType = mimeFileType

	var bucket db.Bucket

	if input.BucketID != nil && len(*input.BucketID) > 0 {
		file.BucketID = *input.BucketID
		bucket.ID = *input.BucketID
	} else {
		err := r.DB.NewSelect().Model(&bucket).Column("id").
			Where("user_id = ?", currentUser.ID).
			Where("organisation_id = ?", currentUser.OrganisationID).
			Where("shared = false").
			Scan(ctx)

		if err != nil && err.Error() == "sql: no rows in result set" {
			// create bucket for user
			bucket.Name = "User Bucket " + currentUser.ID
			bucket.UserID = sql.NullString{String: currentUser.ID, Valid: true}
			bucket.OrganisationID = currentUser.OrganisationID
			err = r.DB.NewInsert().Model(&bucket).Returning("*").Scan(ctx)
			if err != nil {
				return nil, err
			}

			err := r.MinioClient.MakeBucket(ctx, bucket.ID, minio.MakeBucketOptions{})
			if err != nil {
				return nil, err
			}
		} else if err != nil {
			return nil, err
		}

		file.BucketID = bucket.ID
	}

	if input.ParentID != nil && len(*input.ParentID) > 0 {
		file.ParentID = sql.NullString{String: *input.ParentID, Valid: true}
	}

	err = r.DB.NewInsert().Model(&file).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Upload the file to specific bucket with the file id
	_, err = r.MinioClient.PutObject(ctx, bucket.ID, file.ID, input.File.File, input.File.Size, minio.PutObjectOptions{
		ContentType: input.File.ContentType,
	})
	if err != nil {
		return nil, err
	}

	return &file, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, input model.DeleteFileInput) (*model.DeleteFilePayload, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var file db.File
	err = r.DB.NewSelect().Model(&file).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	_, err = r.DB.NewDelete().Model(&file).WherePK().Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: start background job that moves file to trash (cold storage)
	//err = r.MinioClient.RemoveObject(ctx, file.BucketID, file.ID, minio.RemoveObjectOptions{})
	//if err != nil {
	//	return nil, err
	//}

	return &model.DeleteFilePayload{
		Success: true,
		File:    &file,
	}, nil
}

// PreviewFile is the resolver for the previewFile field.
func (r *mutationResolver) PreviewFile(ctx context.Context, input model.PreviewFileInput) (*model.PreviewFilePayload, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var file db.File
	err = r.DB.NewSelect().Model(&file).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	presignedURL, err := r.MinioClient.PresignedGetObject(ctx, file.BucketID, file.ID, time.Second*60, nil)

	if err != nil {
		return nil, err
	}

	return &model.PreviewFilePayload{URL: presignedURL.String()}, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var file db.File
	err = r.DB.NewSelect().Model(&file).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &file, nil
}

// Bucket returns BucketResolver implementation.
func (r *Resolver) Bucket() BucketResolver { return &bucketResolver{r} }

// File returns FileResolver implementation.
func (r *Resolver) File() FileResolver { return &fileResolver{r} }

type bucketResolver struct{ *Resolver }
type fileResolver struct{ *Resolver }
