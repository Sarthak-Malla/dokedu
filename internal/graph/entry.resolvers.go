package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"context"
	"database/sql"
	"example/internal/db"
	"example/internal/graph/model"
	"example/internal/helper"
	"example/internal/middleware"
	"fmt"
	"time"

	"github.com/uptrace/bun"
)

// DeletedAt is the resolver for the deletedAt field.
func (r *entryResolver) DeletedAt(ctx context.Context, obj *db.Entry) (*time.Time, error) {
	if obj.DeletedAt.IsZero() {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// User is the resolver for the user field.
func (r *entryResolver) User(ctx context.Context, obj *db.Entry) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", obj.UserID).Where("organisation_id = ?", currentUser.OrganisationID).WhereAllWithDeleted().Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Users is the resolver for the users field.
func (r *entryResolver) Users(ctx context.Context, obj *db.Entry) ([]*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var users []*db.User

	err = r.DB.NewSelect().
		Model(&users).
		Join("JOIN entry_users eu on user.id = eu.user_id").
		Join("JOIN entries e on eu.entry_id = e.id").
		Where("eu.deleted_at is NULL").
		Where("e.id = ?", obj.ID).
		Where("user.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)

	if err != nil {
		return nil, err
	}

	return users, nil
}

// Events is the resolver for the events field.
func (r *entryResolver) Events(ctx context.Context, obj *db.Entry) ([]*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var events []*db.Event
	err = r.DB.NewSelect().
		Model(&events).
		ColumnExpr("event.*").
		Join("JOIN entry_events ee on event.id = ee.event_id").
		Join("JOIN entries e on ee.entry_id = e.id").
		Where("ee.deleted_at is NULL").
		Where("e.id = ?", obj.ID).
		Where("event.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return events, nil
}

// Files is the resolver for the files field.
func (r *entryResolver) Files(ctx context.Context, obj *db.Entry) ([]*db.File, error) {
	panic(fmt.Errorf("not implemented: Files - files"))
}

// Tags is the resolver for the tags field.
func (r *entryResolver) Tags(ctx context.Context, obj *db.Entry) ([]*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var tags []*db.Tag
	err = r.DB.NewSelect().
		Model(&tags).
		ColumnExpr("tag.*").
		Join("JOIN entry_tags et on tag.id = et.tag_id").
		Join("JOIN entries e on et.entry_id = e.id").
		Where("et.deleted_at is NULL").
		Where("e.id = ?", obj.ID).
		Where("tag.organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return tags, nil
}

// UserCompetences is the resolver for the userCompetences field.
func (r *entryResolver) UserCompetences(ctx context.Context, obj *db.Entry) ([]*db.UserCompetence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var userCompetences []*db.UserCompetence
	err = r.DB.NewSelect().
		Model(&userCompetences).
		Where("entry_id = ?", obj.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)

	if err != nil {
		return nil, err
	}

	return userCompetences, nil
}

// CreateEntry is the resolver for the createEntry field.
func (r *mutationResolver) CreateEntry(ctx context.Context, input model.CreateEntryInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// validate input.Date respects format 2006-01-02
	_, err = time.Parse("2006-01-02", input.Date)
	if err != nil {
		return nil, err
	}

	entry := db.Entry{
		OrganisationID: currentUser.OrganisationID,
		Date:           input.Date,
		Body:           input.Body,
		UserID:         currentUser.ID,
	}
	err = r.DB.NewInsert().Model(&entry).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	if len(input.UserIds) > 0 {
		var entryUsers []*db.EntryUser

		for _, userId := range input.UserIds {
			entryUsers = append(entryUsers, &db.EntryUser{
				EntryID:        entry.ID,
				UserID:         userId,
				OrganisationID: currentUser.OrganisationID,
			})
		}

		err = r.DB.NewInsert().Model(&entryUsers).Returning("*").Scan(ctx)
		if err != nil {
			return nil, err
		}

		// user competences
		if len(input.UserCompetences) > 0 {
			var userCompetences []*db.UserCompetence
			for _, userCompetence := range input.UserCompetences {
				userCompetences = append(userCompetences, &db.UserCompetence{
					UserID:         userCompetence.UserID,
					CompetenceID:   userCompetence.CompetenceID,
					EntryID:        sql.NullString{String: entry.ID, Valid: true},
					Level:          userCompetence.Level,
					OrganisationID: currentUser.OrganisationID,
					CreatedBy:      sql.NullString{String: currentUser.ID, Valid: true},
				})
			}

			err = r.DB.NewInsert().Model(&userCompetences).On("CONFLICT (user_id, competence_id, entry_id) DO UPDATE SET deleted_at = null").Returning("*").Scan(ctx)
			if err != nil {
				return nil, err
			}
		}

	}

	if len(input.TagIds) > 0 {
		var entryTags []*db.EntryTag

		for _, tagId := range input.TagIds {
			entryTags = append(entryTags, &db.EntryTag{
				EntryID:        entry.ID,
				TagID:          tagId,
				OrganisationID: currentUser.OrganisationID,
			})
		}

		err = r.DB.NewInsert().Model(&entryTags).Returning("*").Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	if len(input.FileIds) > 0 {
		var entryFiles []*db.EntryFile

		for _, fileId := range input.FileIds {
			entryFiles = append(entryFiles, &db.EntryFile{
				EntryID:        entry.ID,
				FileID:         fileId,
				OrganisationID: currentUser.OrganisationID,
			})
		}

		err = r.DB.NewInsert().Model(&entryFiles).Returning("*").Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	if len(input.EventIds) > 0 {
		var entryEvents []*db.EntryEvent

		for _, eventId := range input.EventIds {
			entryEvents = append(entryEvents, &db.EntryEvent{
				EntryID:        entry.ID,
				EventID:        eventId,
				OrganisationID: currentUser.OrganisationID,
			})
		}

		err = r.DB.NewInsert().Model(&entryEvents).Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	return &entry, nil
}

// UpdateEntry is the resolver for the updateEntry field.
func (r *mutationResolver) UpdateEntry(ctx context.Context, input model.UpdateEntryInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var entry db.Entry
	entry.ID = input.ID
	err = r.DB.NewSelect().
		Model(&entry).
		Where("organisation_id = ?", currentUser.OrganisationID).
		WherePK().
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	// save input.Date to database
	if input.Date != nil {
		entry.Date = *input.Date
		err = r.DB.NewUpdate().
			Model(&entry).
			Column("date").
			Where("organisation_id = ?", currentUser.OrganisationID).
			WherePK().
			Returning("*").
			Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	// save input.Body to database
	if input.Body != nil {
		entry.Body = *input.Body
		err = r.DB.NewUpdate().
			Model(&entry).
			Column("body").
			Where("organisation_id = ?", currentUser.OrganisationID).
			WherePK().
			Returning("*").
			Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	if len(input.TagIds) >= 0 {
		var entryTags []*db.EntryTag
		err = r.DB.NewDelete().Model(&entryTags).Where("entry_id = ?", entry.ID).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Scan(ctx)
		if err != nil && err.Error() != "sql: no rows in result set" {
			return nil, err
		}
	}

	if len(input.TagIds) > 0 {
		var entryTags []*db.EntryTag

		if input.TagIds != nil {
			for _, tagId := range input.TagIds {
				entryTags = append(entryTags, &db.EntryTag{
					EntryID:        entry.ID,
					TagID:          tagId,
					OrganisationID: currentUser.OrganisationID,
				})
			}
		}

		err = r.DB.NewInsert().
			Model(&entryTags).
			On("CONFLICT (entry_id, tag_id) DO UPDATE").
			Set("deleted_at = null").
			Returning("*").
			Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	if len(input.EventIds) >= 0 {
		err = r.DB.NewDelete().Model(&db.EntryEvent{}).Where("entry_id = ?", entry.ID).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Scan(ctx)
		if err != nil && err.Error() != "sql: no rows in result set" {
			return nil, err
		}
	}

	if len(input.EventIds) > 0 {
		var entryEvents []*db.EntryEvent

		for _, eventId := range input.EventIds {
			entryEvents = append(entryEvents, &db.EntryEvent{
				EntryID:        entry.ID,
				EventID:        eventId,
				OrganisationID: currentUser.OrganisationID,
			})
		}

		err = r.DB.NewInsert().Model(&entryEvents).On("CONFLICT (entry_id, event_id) DO UPDATE").Set("deleted_at = null").Returning("*").Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	if len(input.UserIds) >= 0 {
		err = r.DB.NewDelete().Model(&db.EntryUser{}).Where("entry_id = ?", entry.ID).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Scan(ctx)
		if err != nil && err.Error() != "sql: no rows in result set" {
			return nil, err
		}
	}

	if len(input.UserIds) > 0 {
		var entryUsers []*db.EntryUser

		for _, userId := range input.UserIds {
			entryUsers = append(entryUsers, &db.EntryUser{
				EntryID:        entry.ID,
				UserID:         userId,
				OrganisationID: currentUser.OrganisationID,
			})
		}

		err = r.DB.NewInsert().Model(&entryUsers).On("CONFLICT (entry_id, user_id) DO UPDATE").Set("deleted_at = null").Scan(ctx)
		if err != nil {
			return nil, err
		}

	}

	if len(input.UserCompetences) >= 0 {
		err = r.DB.NewDelete().Model(&db.UserCompetence{}).Where("entry_id = ?", entry.ID).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Scan(ctx)
		if err != nil && err.Error() != "sql: no rows in result set" {
			return nil, err
		}
	}

	// user competences
	if len(input.UserCompetences) > 0 {
		var userCompetences []*db.UserCompetence

		for _, userCompetence := range input.UserCompetences {
			userCompetences = append(userCompetences, &db.UserCompetence{
				EntryID:        sql.NullString{String: input.ID, Valid: true},
				UserID:         userCompetence.UserID,
				CompetenceID:   userCompetence.CompetenceID,
				OrganisationID: currentUser.OrganisationID,
				Level:          userCompetence.Level,
				CreatedBy:      sql.NullString{String: currentUser.ID, Valid: true},
			})
		}

		err = r.DB.NewInsert().
			Model(&userCompetences).
			On("CONFLICT (entry_id, user_id, competence_id) DO UPDATE").
			Set("deleted_at = null").
			Set("level = EXCLUDED.level").
			Returning("*").
			Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	return &entry, nil
}

// ArchiveEntry is the resolver for the archiveEntry field.
func (r *mutationResolver) ArchiveEntry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// set deleted_at field to the current time
	entry := db.Entry{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
		DeletedAt: bun.NullTime{
			Time: time.Now(),
		},
	}
	_, err = r.DB.
		NewUpdate().
		Model(&entry).
		Column("deleted_at").
		Where("id = ?", id).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// Entry is the resolver for the entry field.
func (r *queryResolver) Entry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var entry db.Entry
	err = r.DB.NewSelect().Model(&entry).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// Entries is the resolver for the entries field.
func (r *queryResolver) Entries(ctx context.Context, limit *int, offset *int, filter *model.EntryFilterInput, sortBy *model.EntrySortBy, search *string) (*model.EntryConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var entries []*db.Entry
	query := r.DB.NewSelect().
		Model(&entries).
		Distinct().
		Join("LEFT JOIN entry_users eu ON entry.id = eu.entry_id").
		Where("eu.deleted_at IS NULL").
		Join("LEFT JOIN entry_tags et ON entry.id = et.entry_id").
		Where("et.deleted_at IS NULL").
		Where("entry.organisation_id = ?", currentUser.OrganisationID).
		Limit(pageLimit).Offset(pageOffset)

	if filter != nil {
		if filter.Users != nil && len(filter.Users) > 0 {
			query.Where("eu.user_id IN (?)", bun.In(filter.Users))
		}
		if filter.Authors != nil && len(filter.Authors) > 0 {
			query.Where("entry.user_id IN (?)", bun.In(filter.Authors))
		}
		if filter.Tags != nil && len(filter.Tags) > 0 {
			query.Where("et.tag_id IN (?)", bun.In(filter.Tags))
			query.Where("(SELECT COUNT(DISTINCT et2.tag_id) FROM entry_tags et2 WHERE et2.entry_id = entry.id) >= ?", len(filter.Tags))
		}
	}

	if sortBy != nil {
		switch *sortBy {
		case model.EntrySortByCreatedAtAsc:
			query.Order("entry.created_at ASC")
		case model.EntrySortByCreatedAtDesc:
			query.Order("entry.created_at DESC")
		case model.EntrySortByDateAsc:
			query.Order("entry.date ASC")
		case model.EntrySortByDateDesc:
			query.Order("entry.date DESC")
		default:
			query.Order("entry.created_at DESC")
		}
	}

	count, err := query.ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	// Page info
	page, err := helper.CreatePageInfo(*limit, *offset, count)
	if err != nil {
		return nil, err
	}

	page.CurrentPage = pageOffset / pageLimit
	return &model.EntryConnection{
		Edges:      entries,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// Entry returns EntryResolver implementation.
func (r *Resolver) Entry() EntryResolver { return &entryResolver{r} }

type entryResolver struct{ *Resolver }
